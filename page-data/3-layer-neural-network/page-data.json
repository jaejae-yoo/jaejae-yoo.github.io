{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/3-layer-neural-network","result":{"data":{"post":{"__typename":"MdxPost","slug":"/3-layer-neural-network","title":"3 layer neural network","date":"29.09.2020","tags":[{"name":"DL","slug":"dl"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"3 layer neural network\",\n  \"date\": \"2020-09-29T00:00:00.000Z\",\n  \"tags\": [\"DL\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"h3\", {\n    parentName: \"blockquote\"\n  }, \"Perceptron VS neural network\")), mdx(\"p\", null, \"\\uD37C\\uC149\\uD2B8\\uB860\\uC740 \\uC218\\uB3D9\\uC73C\\uB85C \\uC6D0\\uD558\\uB294 \\uACB0\\uACFC\\uB97C \\uB3C4\\uCD9C\\uD558\\uAE30 \\uC704\\uD574 \\uC218\\uB3D9\\uC73C\\uB85C \\uAC00\\uC911\\uCE58\\uB97C \\uC124\\uC815\\uD574\\uC57C \\uD55C\\uB2E4.\"), mdx(\"p\", null, \"\\uC2E0\\uACBD\\uB9DD\\uC740 \\uAC00\\uC911\\uCE58 \\uB9E4\\uAC1C\\uBCC0\\uC218\\uC758 \\uC801\\uC808\\uD55C \\uAC82\\uC744 \\uB370\\uC774\\uD130\\uB85C\\uBD80\\uD130 \\uC790\\uB3D9\\uC73C\\uB85C \\uD559\\uC2B5\\uD558\\uAE30 \\uB54C\\uBB38\\uC5D0 \\uD37C\\uC149\\uD2B8\\uB860\\uC758 \\uB2E8\\uC810\\uC744 \\uBCF4\\uC644\\uD560 \\uC218 \\uC788\\uB2E4\"), mdx(\"blockquote\", null, mdx(\"h3\", {\n    parentName: \"blockquote\"\n  }, \"3 layer neural network \\uC218\\uC2DD \\uD45C\\uD604\")), mdx(\"p\", null, \"\\uC785\\uB825\\uCE35(0\\uCE35)\\uC5D0 \\uB274\\uB7F0 2\\uAC1C\\uC640 \\uD3B8\\uD5A5 \\uB274\\uB7F0 1\\uAC1C, \\uCCAB \\uBC88\\uC9F8 \\uC740\\uB2C9\\uCE35(1\\uCE35) 3\\uAC1C, \\uB450 \\uBC88\\uC9F8 \\uC740\\uB2C9\\uCE35(2\\uCE35) 2\\uAC1C \\uCD9C\\uB825\\uCE35(3\\uCE35)\\uC73C\\uB85C \\uAD6C\\uC131\\uB41C \\uC2E0\\uACBD\\uB9DD \\uAD6C\\uD604.\"), mdx(\"h5\", null, \"input layer \\u279C 1 layer\\uB85C \\uC2E0\\uD638 \\uC804\\uB2EC\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a1(1) = w11(1) x1 + w12 (1) x2 + b1(1)\\na2(1) = w21(1) x1 + w22(1) x 2 + b2(1)\\na3(1) = w31(1) x1 + w32 (1) x2 + b3(1)\\nA(1) = W(1) * X + B(1)\\n\")), mdx(\"h5\", null, \"1 layer\\uC5D0\\uC11C \\u279C 2 layer\\uB85C \\uC2E0\\uD638 \\uC804\\uB2EC\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a1(2) = w11(2) z1(1)1 + w12 (2) z2(1) + w13(2)* z3(1) + b1(2)\\na2(2) = w21(2) z1(1) + w22(2) z2(1) + w23(2)* z3(1) + b2(2)\\nA(2) = W(2) * Z(1) + B(2)\\n\")), mdx(\"h5\", null, \"2 layer \\u279C output layer\\uB85C \\uC2E0\\uD638 \\uC804\\uB2EC\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a1(3) = w11(3) z1(2)1 + w12 (3) z2(2) + b1(3)\\na2(3) = w21(3) z1(2) + w22(3) z2(2) + b2(3)\\nA(3) = W(3) * Z(2) + B(3)\\n\")), mdx(\"br\", null), mdx(\"br\", null), mdx(\"blockquote\", null, mdx(\"h3\", {\n    parentName: \"blockquote\"\n  }, \"3 layer neural network CODE\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"    import numpy as np\\n\\n    #\\uD65C\\uC131\\uD654 \\uD568\\uC218\\n    def sigmoid(x):\\n        return 1 / (1 + np.exp(-x))\\n    \\n    #\\uD56D\\uB4F1 \\uD568\\uC218\\n    def identity_function(x):\\n        return x\\n\\n    #\\uC785\\uB825\\uCE35\\uC5D0\\uC11C 1\\uCE35\\uC73C\\uB85C \\uC2E0\\uD638\\uC804\\uB2EC\\n    X = np.array([1.0, 0.5])\\n    W1 = np.array([[0.1, 0.3, 0.5],[0.2, 0.4, 0.6]])\\n    B1 = np.array([0.1, 0.2, 0.3])\\n\\n    A1 = np.dot(X, W1) + B1\\n\\n    #1\\uCE35\\uC5D0\\uC11C 2\\uCE35\\uC73C\\uB85C \\uC2E0\\uD638 \\uC804\\uB2EC\\n    Z1 = sigmoid(A1)\\n    W2 = np.array([[0.1, 0.4],[0.2, 0.5],[0.3, 0.6]])\\n    B2 = np.array([0.1, 0.2])\\n\\n    A2 = np.dot(Z1, W2) + B2\\n\\n    #2\\uCE35\\uC5D0\\uC11C \\uCD9C\\uB825\\uCE35\\uC73C\\uB85C \\uC2E0\\uD638 \\uC804\\uB2EC\\n    Z2 = sigmoid(A2)\\n\\n    W3 = np.array([[0.1, 0.3],[0.2, 0.4]])\\n    B3 = np.array([0.1, 0.2])\\n\\n    A3 = np.dot(Z2, W3) + B3\\n    #\\uCD9C\\uB825\\n    Y = identity_function(A3)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Perceptron VS neural network 퍼셉트론은 수동으로 원하는 결과를 도출하기 위해 수동으로 가중치를 설정해야 한다. 신경망은 가중치 매개변수의 적절한 겂을 데이터로부터 자동으로 학습하기 때문에 퍼셉트론의 단점을 보완할 수 있다…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/3-layer-neural-network","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}